'''Напишите программу, которая запрашивает ввод двух значений. Если хотя бы одно из них не является числом,
 то должна выполняться конкатенация
, т. е. соединение, строк. В остальных случаях введенные числа суммируются.'''
x = input("Введите что-то")
y = input("Введите  что-то")
try:
    a = int(x)
    b = int(y)
    c = a + b
except ValueError:
    c = x + y

print(c)
'''За столом сидят n гостей (вводится с клавиатуры), перед которыми стоит пирог. Пирог и его 
части можно делить только пополам. Определите, сколько раз нужно делить пирог на ещё более мелкие части, чтобы:

каждому из гостей достался хотя бы 1 кусок;
как минимум половине гостей досталось по 2 куска;
каждому гостю досталось по 1 куску и при этом ещё хотя бы 10 кусков осталось в запасе.'''
#каждому из гостей достался хотя бы 1 кусок
n = int(input())
delt = 0
x = 1
while x < n:
    delt += 1
    x *= 2
print(delt)
#как минимум половине гостей досталось по 2 куска
delt = 0
x= 1
while x < (n + round(n/2)):
    delt += 1
    x *= 2
print(x)
# каждому гостю досталось по 1 куску и при этом ещё хотя бы 10 кусков осталось в запасе
delt = 0
x = 1
while x < n+10:
    delt += 1
    x *= 2
print(delt)
'''Для n-го члена в последовательности Фибоначчи существует явная формула:
Поскольку операции с вещественными числами происходят с конечной точностью, то с ростом n, 
результат вычисления по этой формуле будет все больше отличаться от настоящего числа Фибоначчи. Найдите n, 
начиная с которого, отличие от истинного значения превысит 0.001.'''
import math
def pure_Fibonachi(n):
    xn = (1 + math.sqrt(5)) / 2
    fib = float((1/2) * ((xn ** (n + 1)) - ((1 - xn) ** (n + 1))))
    return fib
n=1
while True:
    Fibonachi = pure_Fibonachi(n)
    round_fibonacci = round (pure_Fibonachi())
    if abs(round_fibonacci - pure_Fibonachi()) > 0.001:
        break
    n += 1
print(n)
'''В детском садике n детей играют в следующую игру. Перед ними гора из m кубиков, первый ребёнок вынимает из 
кучи 1 кубик, каждый последующий ребёнок в два раза больше предыдущего и так по кругу. 
Если число кубиков, которые нужно вынуть, превышает 25, из него вычитается 25 и отсчёт идёт от уменьшенного числа,
 например, вместо 32 кубиков будет вынуто 7, затем 14 и т. д. Проигравшим считается тот, кто не смог вытащить 
 нужное число кубиков 
(в куче осталось недостаточно). Определите проигравшего.'''

n = int(input(" количество детей"))
m = int(input(" количество кубиков"))
def lost(m): #номер конечного раунда
    cube = 1
    match = 1
    while cube <= m:
        if cube > 25:
            cube -= 25
            m= m - cube
        else:
            m = m - cube
            cube *=2
        match += 1
    return match
all_matches = lost(m)


def last_kind(ma):
    if ma <= n:
        lkind = ma
    else:
        while ma > n:
            lkind =ma - n
            ma = ma - n
    return lkind



print("проигрыш у номера  ", last_kind(all_matches))
'''Вот общая схема того, как переместить башню с исходного стержня на заданный с использованием промежуточного:

Передвинуть башню из (количество дисков - 1) на промежуточный колышек, используя при этом заданный.
Положить оставшийся диск на заданный стержень.
Переместить башню из оставшихся на промежуточном стержне дисков на конечный, используя при
 этом первоначальный колышек.
Напишите функцию move (n, x, y), которая печатает последовательность перекладываний дисков для
 перемещения пирамидки высоты n со стержня номер x на стержень номер y.

Реализуйте алгоритм в двух вариантах: на основе цикла и на основе рекурсии.'''
def move(height,fromT, toT, through):
    if height == 1:
        print(f"Переместить диск 1 с {fromT} на {through}.")
    else:
        move(height - 1, fromT, through, toT)
        print(f"Переместить диск {height} с {fromT} на {through}.")
        move(height - 1, toT, fromT, through)

def Towers(height, fromT, toT, through):
    if height % 2 == 0:
        toT, through = through, toT

    for i in range(1, height + 1):
        if i % 2 == 0:
            print(f"Переместить диск {i}с {fromT} на {through}.")
        else:
            print(f"Переместить диск {i} с {fromT} на {toT}.")

    for i in range(1, height + 1):
        if i % 2 == 0:
            print(f"Переместить диск {i} с {toT} на {through}.")
        else:
            print(f"Переместить диск {i} с {toT} на {through}.")
move(3, 'A', 'B', 'C')
print( "Конец")
Towers(3, 'A', 'B', 'C')
print("Конец ")
'''Написать программу совершающую элементарные алгебраические операции  с числами в произвольной системе исчисления.
 )'''

def convert_base2(num, to_base=10, from_base=10):
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    if isinstance(num, str):  # праверка типа, аналогично type(num) == str
        n = int(num, from_base)  # приведение к десятичной базе (ЗАГЛУШКА)
    else:
        n = int(num)
    # приведение к новой базе
    if n < to_base:
        return alphabet[n]
    else:
        return convert_base2(n // to_base, to_base) + alphabet[n % to_base]
x=input('введите 1-oe число')
y=int(input('ВВедите его систему счисления'))

A=int(convert_base2(x,10, y))
x=input('введите 1-oe число')
y=int(input('ВВедите его систему счисления'))
B=int(convert_base2(x,10, y))
print("Kакую операцию с ними нужно выполнить/n"
      "1:Найти сумму введённых чисел2:Найти произведение введённых чисел.3:A/B"
      "4:Найти разность введённых чисел")
n=int(input())
to=int(input('введите систему счисления, в которой нужен результат'))
if n==1:
    summ=A+B
    print(convert_base2(summ,to,10))
if n==2:
    mult=A*B
    print(convert_base2(mult,to,10))
if n==3:
    di=A/B
    print(convert_base2(di,to,10))
if n==4:
    sub=A-B
    print(convert_base2(sub,to,10))

'''Напишите программу, реализующую этот алгоритм. Для этого напишите функцию для 
быстрого вычисления обратного корня Q_rsqrt(), оцените ошибку такого метода вычисления.
Сделайте одну итерацию с помощью метода Ньютона, 
котoрая в данном случае имеет вид:'''
'''Напишите программу, реализующую этот алгоритм. Для этого напишите функцию для 
быстрого вычисления обратного корня Q_rsqrt(), оцените ошибку такого метода вычисления.
Сделайте одну итерацию с помощью метода Ньютона,
котoрая в данном случае имеет вид:'''
def  Q_rsqrt(x):

    const = 0x5F3759DF

    y = ((const * x) >> 1) & 0x7FFFFFFF

    y = y + (x / y) - 1
    return y

x = 2
print( Q_rsqrt(x))
'''апишите программу, реализующую этот алгоритм. 
Представьте входные и выходные данные в виде формата list хранящего значения x и y.'''

def Karatsuba(x,y):
    if  len(str(y)) == 1 or len(str(x)) == 1:
        return x * y

    m = max(len(str(x)), len(str(y)))
    m2 = m // 2


    a = x // 10 ** (m2)
    b = x % 10 ** (m2)
    c = y // 10 ** (m2)
    d = y % 10 ** (m2)


    z0 = Karatsuba(b, d)
    z1 = Karatsuba((a + b), (c + d))
    z2 = Karatsuba(a, c)


    return z2 * 10 ** (2 * m2) + ((z1 - z2 - z0) * 10 ** m2) + z0

a=[]
for i in range(2):
    a.append(int(input('введите число')))
x=a[0]
y=a[1]
print([Karatsuba(x,y)])

